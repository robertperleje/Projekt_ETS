# SSH Tunnel Manager - Dokumentacja

> Biblioteka Python do zarzƒÖdzania tunelami SSH z automatycznym lifecycle management. Idealna do bezpiecznego dostƒôpu do port√≥w niedostƒôpnych publicznie, szczeg√≥lnie dla JBoss CLI, baz danych i innych serwis√≥w wewnƒôtrznych.

## üìã Spis tre≈õci

- [Wprowadzenie](#wprowadzenie)
- [Jak dzia≈Ça tunel SSH](#jak-dzia≈Ça-tunel-ssh)
- [Instalacja](#instalacja)
- [Funkcja Python - SSHTunnel](#funkcja-python---sshtunnel)
- [Przyk≈Çady u≈ºycia](#przyk≈Çady-u≈ºycia)
- [Integracja z Jenkins](#integracja-z-jenkins)
- [Bezpiecze≈Ñstwo](#bezpiecze≈Ñstwo)
- [Troubleshooting](#troubleshooting)
- [FAQ](#faq)

---

## üéØ Wprowadzenie

### Problem

W ≈õrodowiskach korporacyjnych czƒôsto mamy serwisy dostƒôpne tylko lokalnie (np. JBoss CLI na porcie 9990/19990), kt√≥re nie sƒÖ eksponowane przez firewall. Bezpo≈õredni dostƒôp wymaga≈Çby otwarcia dodatkowych port√≥w, co:

- ‚ùå Zwiƒôksza powierzchniƒô ataku
- ‚ùå Wymaga dodatkowych zmian w firewallu
- ‚ùå Komplikuje zarzƒÖdzanie bezpiecze≈Ñstwem
- ‚ùå Nie szyfruje komunikacji

### RozwiƒÖzanie

Tunel SSH pozwala na:

- ‚úÖ Bezpieczny dostƒôp przez **jeden** port (22)
- ‚úÖ Szyfrowanie ca≈Çej komunikacji
- ‚úÖ Brak potrzeby otwierania dodatkowych port√≥w
- ‚úÖ Prosty lifecycle management przez Python

---

## üîê Jak dzia≈Ça tunel SSH

### Podstawowa koncepcja

SSH Tunnel (Port Forwarding) to mechanizm, kt√≥ry pozwala przekierowaƒá ruch sieciowy z lokalnego portu przez szyfrowane po≈ÇƒÖczenie SSH do portu na zdalnym serwerze.

### Wizualizacja przep≈Çywu danych

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         ARCHITEKTURA TUNELU SSH                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

Klient (Jenkins)                              Serwer (jboss01)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ                             ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

localhost:19990                               localhost:19990
     ‚îÇ                                              ‚ñ≤
     ‚îÇ 1. Aplikacja ≈ÇƒÖczy siƒô                       ‚îÇ
     ‚îÇ    z localhost:19990                         ‚îÇ 4. SSH przekierowuje
     ‚îÇ                                              ‚îÇ    do lokalnego portu
     ‚ñº                                              ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              ‚îÇ  2. Dane sƒÖ szyfrowane     ‚îÇ              ‚îÇ
‚îÇ Tunel SSH    ‚îÇ     i wysy≈Çane przez       ‚îÇ  SSH Daemon  ‚îÇ
‚îÇ (port 22)    ‚îÇ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê INTERNET ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê>‚îÇ  (port 22)   ‚îÇ
‚îÇ              ‚îÇ     (BEZPIECZNY KANA≈Å)     ‚îÇ              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                    ‚îÇ
                                                    ‚îÇ 3. SSH odbiera
                                                    ‚îÇ    i rozpakowuje
                                                    ‚ñº
                                             ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                             ‚îÇ  JBoss CLI   ‚îÇ
                                             ‚îÇ  :19990      ‚îÇ
                                             ‚îÇ (LOKALNIE)   ‚îÇ
                                             ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Krok po kroku

1. **Utworzenie tunelu:**
   ```bash
   ssh -L 19990:localhost:19990 user@jboss01
   ```

2. **Co siƒô dzieje:**
   - SSH tworzy lokalny port `19990` na kliencie
   - Wszystkie dane wys≈Çane na `localhost:19990` sƒÖ przechwytywane
   - Dane sƒÖ szyfrowane algorytmami SSH (AES-256, ChaCha20)
   - Dane wƒôdrujƒÖ tunelem SSH na port `22` serwera
   - Na serwerze SSH rozpakowuje dane i przekierowuje do `localhost:19990`

3. **Rezultat:**
   - Aplikacja my≈õli, ≈ºe ≈ÇƒÖczy siƒô lokalnie z `localhost:19990`
   - W rzeczywisto≈õci komunikuje siƒô ze zdalnym serwerem
   - Ca≈Ça komunikacja jest szyfrowana
   - Nie ma potrzeby otwierania portu `19990` w firewallu

### Por√≥wnanie z bezpo≈õrednim po≈ÇƒÖczeniem

#### Bez tunelu SSH (wymaga 2 otwarte porty):

```
Firewall musi przepu≈õciƒá:
‚îú‚îÄ‚îÄ Port 22 (SSH)      ‚úÖ
‚îî‚îÄ‚îÄ Port 19990 (CLI)   ‚úÖ ‚Üê dodatkowy port do otwarcia!

Bezpiecze≈Ñstwo: ‚ö†Ô∏è ≈õrednie
- Dwa punkty wej≈õcia
- JBoss CLI eksponowany publicznie
- Potencjalnie nieszyfrowana komunikacja z CLI
```

#### Z tunelem SSH (tylko 1 otwarty port):

```
Firewall musi przepu≈õciƒá:
‚îî‚îÄ‚îÄ Port 22 (SSH)      ‚úÖ TYLKO TEN!

Port 19990: ‚ùå NIE MUSI byƒá otwarty - dostƒôpny tylko lokalnie!

Bezpiecze≈Ñstwo: ‚úÖ wysokie
- Jeden punkt wej≈õcia
- JBoss CLI niewidoczny z zewnƒÖtrz
- Ca≈Ça komunikacja szyfrowana przez SSH
```

### Algorytmy szyfrowania SSH

SSH u≈ºywa nowoczesnych algorytm√≥w:

- **Wymiana kluczy:** Diffie-Hellman, ECDH, Curve25519
- **Szyfrowanie:** AES-256-GCM, ChaCha20-Poly1305
- **Integralno≈õƒá:** HMAC-SHA2-256, HMAC-SHA2-512
- **Klucze:** RSA-4096, Ed25519, ECDSA

```bash
# Sprawd≈∫ szczeg√≥≈Çy po≈ÇƒÖczenia:
ssh -v user@host

# Przyk≈Çadowy output:
# debug1: kex: server->client cipher: aes256-gcm@openssh.com
# debug1: kex: client->server cipher: aes256-gcm@openssh.com
```

---

## üì¶ Instalacja

### Wymagania

- Python 3.7+
- OpenSSH client
- Dostƒôp SSH do serwera docelowego

### Instalacja zale≈ºno≈õci

```bash
# Standardowa biblioteka Python - brak dodatkowych zale≈ºno≈õci!
# U≈ºywamy tylko modu≈Ç√≥w built-in:
# - subprocess
# - socket
# - time
# - sys
```

### Konfiguracja SSH

#### 1. Generowanie kluczy SSH (zalecane)

```bash
# Generuj parƒô kluczy Ed25519 (najnowszy standard)
ssh-keygen -t ed25519 -C "jenkins@company.com"

# Skopiuj klucz publiczny na serwer
ssh-copy-id user@jboss01

# Sprawd≈∫ po≈ÇƒÖczenie bez has≈Ça
ssh user@jboss01
```

#### 2. Konfiguracja SSH config (opcjonalne)

Utw√≥rz lub edytuj `~/.ssh/config`:

```bash
Host jboss01
    HostName 10.10.10.25
    User jenkins
    IdentityFile ~/.ssh/id_ed25519
    ServerAliveInterval 60
    ServerAliveCountMax 3
    StrictHostKeyChecking no
```

Teraz mo≈ºesz ≈ÇƒÖczyƒá siƒô po prostu: `ssh jboss01`

---

## üêç Funkcja Python - SSHTunnel

### Pe≈Çny kod ≈∫r√≥d≈Çowy

```python
"""
SSH Tunnel Manager
==================

Biblioteka do zarzƒÖdzania tunelami SSH z automatycznym lifecycle management.

Autor: DevOps Team
Wersja: 1.0.0
Licencja: MIT
"""

import subprocess
import time
import socket
import sys
import signal
import os


class SSHTunnel:
    """
    ZarzƒÖdza tunelem SSH z automatycznym lifecycle management.
    
    Obs≈Çuguje:
    - Tworzenie tuneli SSH (Local Port Forwarding)
    - Sprawdzanie czy tunel ju≈º dzia≈Ça
    - Automatyczne zamykanie tuneli
    - Wykonywanie polece≈Ñ przez tunel
    - Context manager dla bezpiecznego zarzƒÖdzania
    
    Przyk≈Çad u≈ºycia:
        with SSHTunnel('jboss01', 19990) as tunnel:
            # Wykonaj polecenia przez tunel
            tunnel.execute_command(['curl', 'localhost:19990'])
    """
    
    def __init__(self, remote_host, remote_port, local_port=None, ssh_user='jenkins'):
        """
        Inicjalizuje tunel SSH.
        
        Args:
            remote_host (str): Nazwa hosta lub IP docelowego serwera
            remote_port (int): Port na zdalnym ho≈õcie (np. 19990 dla JBoss CLI)
            local_port (int, optional): Port lokalny. Domy≈õlnie taki sam jak remote_port
            ssh_user (str, optional): U≈ºytkownik SSH. Domy≈õlnie 'jenkins'
        
        Przyk≈Çad:
            tunnel = SSHTunnel('jboss01', 19990, local_port=9990, ssh_user='admin')
        """
        self.remote_host = remote_host
        self.remote_port = remote_port
        self.local_port = local_port if local_port else remote_port
        self.ssh_user = ssh_user
        self.tunnel_process = None
        
    def is_port_open(self, host, port):
        """
        Sprawdza czy port jest dostƒôpny.
        
        Args:
            host (str): Nazwa hosta lub IP
            port (int): Numer portu
            
        Returns:
            bool: True je≈õli port jest otwarty, False w przeciwnym wypadku
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception as e:
            return False
    
    def is_tunnel_running(self):
        """
        Sprawdza czy tunel SSH ju≈º dzia≈Ça.
        
        U≈ºywa pgrep do wyszukania procesu SSH z odpowiednimi parametrami.
        
        Returns:
            bool: True je≈õli tunel dzia≈Ça, False w przeciwnym wypadku
        """
        cmd = f"pgrep -f 'ssh.*{self.local_port}:localhost:{self.remote_port}.*{self.remote_host}'"
        result = subprocess.run(cmd, shell=True, capture_output=True)
        return result.returncode == 0
    
    def start(self):
        """
        Uruchamia tunel SSH.
        
        Je≈õli tunel ju≈º dzia≈Ça, nie tworzy nowego.
        Po utworzeniu tunelu czeka 2 sekundy i sprawdza czy port jest dostƒôpny.
        
        Returns:
            bool: True je≈õli tunel dzia≈Ça, False w przypadku b≈Çƒôdu
            
        Przyk≈Çad:
            tunnel = SSHTunnel('jboss01', 19990)
            if tunnel.start():
                print("Tunel gotowy!")
        """
        if self.is_tunnel_running():
            print(f"‚úì Tunel SSH ju≈º dzia≈Ça dla {self.remote_host}:{self.remote_port}")
            return True
        
        print(f"üîß Tworzƒô tunel SSH: localhost:{self.local_port} -> {self.remote_host}:{self.remote_port}")
        
        # Komenda SSH do utworzenia tunelu
        ssh_cmd = [
            'ssh',
            '-f',  # Uruchom w tle (fork do background)
            '-N',  # Nie wykonuj polece≈Ñ zdalnych (No remote command)
            '-L', f'{self.local_port}:localhost:{self.remote_port}',  # Local port forwarding
            f'{self.ssh_user}@{self.remote_host}',
            '-o', 'StrictHostKeyChecking=no',  # Nie pytaj o fingerprint (produkcja: usu≈Ñ!)
            '-o', 'ServerAliveInterval=60',    # Ping co 60s
            '-o', 'ServerAliveCountMax=3'      # Zamknij po 3 nieudanych pingach
        ]
        
        try:
            subprocess.run(ssh_cmd, check=True, capture_output=True, text=True)
            time.sleep(2)  # Poczekaj na nawiƒÖzanie po≈ÇƒÖczenia
            
            # Sprawd≈∫ czy tunel dzia≈Ça
            if self.is_port_open('localhost', self.local_port):
                print(f"‚úì Tunel SSH uruchomiony pomy≈õlnie!")
                return True
            else:
                print(f"‚úó Tunel SSH nie odpowiada na porcie {self.local_port}")
                return False
                
        except subprocess.CalledProcessError as e:
            print(f"‚úó B≈ÇƒÖd przy tworzeniu tunelu SSH:")
            print(f"   Stderr: {e.stderr}")
            return False
        except Exception as e:
            print(f"‚úó Nieoczekiwany b≈ÇƒÖd: {e}")
            return False
    
    def stop(self):
        """
        Zatrzymuje tunel SSH.
        
        U≈ºywa pkill do zabicia procesu SSH z odpowiednimi parametrami.
        """
        print(f"üîß Zamykam tunel SSH dla {self.remote_host}:{self.remote_port}")
        cmd = f"pkill -f 'ssh.*{self.local_port}:localhost:{self.remote_port}.*{self.remote_host}'"
        subprocess.run(cmd, shell=True, stderr=subprocess.DEVNULL)
        time.sleep(1)
        print("‚úì Tunel SSH zamkniƒôty")
    
    def execute_command(self, command, timeout=60):
        """
        Wykonuje polecenie przez tunel SSH.
        
        Automatycznie uruchamia tunel je≈õli nie dzia≈Ça.
        
        Args:
            command (list): Lista z poleceniem i argumentami
            timeout (int): Timeout w sekundach (domy≈õlnie 60)
            
        Returns:
            tuple: (return_code, stdout, stderr)
            
        Przyk≈Çad:
            tunnel = SSHTunnel('jboss01', 19990)
            rc, out, err = tunnel.execute_command(['curl', 'localhost:19990/health'])
            if rc == 0:
                print(f"Odpowied≈∫: {out}")
        """
        if not self.start():
            return (1, "", "Nie mo≈ºna uruchomiƒá tunelu SSH")
        
        print(f"‚ñ∂ Wykonujƒô polecenie przez tunel...")
        
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=timeout
            )
            
            return (result.returncode, result.stdout, result.stderr)
            
        except subprocess.TimeoutExpired:
            return (1, "", f"Timeout - polecenie przekroczy≈Ço limit {timeout}s")
        except Exception as e:
            return (1, "", f"B≈ÇƒÖd wykonania: {str(e)}")
    
    def __enter__(self):
        """
        Context manager - wej≈õcie.
        
        Automatycznie uruchamia tunel przy wej≈õciu do bloku 'with'.
        """
        self.start()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Context manager - wyj≈õcie.
        
        Automatycznie zamyka tunel przy wyj≈õciu z bloku 'with',
        nawet je≈õli wystƒÖpi≈Ç b≈ÇƒÖd.
        """
        self.stop()
        return False  # Nie przyt≈Çumiaj wyjƒÖtk√≥w


def check_jboss_status(hostname, cli_port=19990, jboss_cli_path='/opt/jboss/bin/jboss-cli.sh'):
    """
    Sprawdza status JBoss przez CLI u≈ºywajƒÖc tunelu SSH.
    
    Args:
        hostname (str): Nazwa hosta JBoss
        cli_port (int): Port JBoss CLI (domy≈õlnie 19990)
        jboss_cli_path (str): ≈öcie≈ºka do jboss-cli.sh
        
    Returns:
        bool: True je≈õli JBoss dzia≈Ça, False w przeciwnym wypadku
        
    Przyk≈Çad:
        if check_jboss_status('jboss01'):
            print("JBoss dzia≈Ça poprawnie!")
    """
    print(f"\n{'='*60}")
    print(f"Sprawdzam status JBoss na: {hostname}:{cli_port}")
    print(f"{'='*60}\n")
    
    # U≈ºyj context managera - tunel zostanie automatycznie zamkniƒôty
    with SSHTunnel(hostname, cli_port) as tunnel:
        # Komenda JBoss CLI
        command = [
            jboss_cli_path,
            '--connect',
            f'--controller=localhost:{cli_port}',
            '--command=:read-attribute(name=server-state)'
        ]
        
        return_code, stdout, stderr = tunnel.execute_command(command)
        
        print(f"\n{'='*60}")
        if return_code == 0:
            print("‚úì Status JBoss:")
            print(stdout)
            print(f"{'='*60}\n")
            return True
        else:
            print("‚úó B≈ÇƒÖd sprawdzania statusu:")
            print(stderr)
            print(f"{'='*60}\n")
            return False


if __name__ == "__main__":
    """
    Przyk≈Çad u≈ºycia z linii polece≈Ñ.
    
    U≈ºycie:
        python ssh_tunnel.py <hostname> [cli_port]
        
    Przyk≈Çad:
        python ssh_tunnel.py jboss01 19990
    """
    if len(sys.argv) < 2:
        print("U≈ºycie: python ssh_tunnel.py <hostname> [cli_port]")
        print("\nPrzyk≈Çad:")
        print("  python ssh_tunnel.py jboss01 19990")
        sys.exit(1)
    
    hostname = sys.argv[1]
    cli_port = int(sys.argv[2]) if len(sys.argv) > 2 else 19990
    
    success = check_jboss_status(hostname, cli_port)
    sys.exit(0 if success else 1)
```

### API Reference

#### Klasa SSHTunnel

| Metoda | Parametry | Zwraca | Opis |
|--------|-----------|--------|------|
| `__init__()` | `remote_host`, `remote_port`, `local_port=None`, `ssh_user='jenkins'` | - | Inicjalizuje tunel |
| `start()` | - | `bool` | Uruchamia tunel SSH |
| `stop()` | - | - | Zatrzymuje tunel SSH |
| `is_tunnel_running()` | - | `bool` | Sprawdza czy tunel dzia≈Ça |
| `is_port_open()` | `host`, `port` | `bool` | Sprawdza dostƒôpno≈õƒá portu |
| `execute_command()` | `command`, `timeout=60` | `(int, str, str)` | Wykonuje polecenie przez tunel |

#### Funkcje pomocnicze

| Funkcja | Parametry | Zwraca | Opis |
|---------|-----------|--------|------|
| `check_jboss_status()` | `hostname`, `cli_port=19990`, `jboss_cli_path` | `bool` | Sprawdza status JBoss |

---

## üí° Przyk≈Çady u≈ºycia

### 1. Podstawowe u≈ºycie - Context Manager

```python
from ssh_tunnel import SSHTunnel

# Automatyczne zarzƒÖdzanie lifecycle
with SSHTunnel('jboss01', 19990) as tunnel:
    # Tunel jest otwarty
    command = ['curl', 'http://localhost:19990/health']
    rc, out, err = tunnel.execute_command(command)
    
    if rc == 0:
        print(f"Status: {out}")
# Tunel zostaje automatycznie zamkniƒôty
```

### 2. Rƒôczne zarzƒÖdzanie tunelem

```python
from ssh_tunnel import SSHTunnel

tunnel = SSHTunnel('jboss01', 19990, ssh_user='admin')

try:
    if tunnel.start():
        # Wykonaj operacje
        rc, out, err = tunnel.execute_command(['curl', 'localhost:19990'])
        print(out)
finally:
    tunnel.stop()  # Zawsze zamknij tunel
```

### 3. JBoss CLI - sprawdzanie statusu

```python
from ssh_tunnel import check_jboss_status

# Prosta funkcja do sprawdzania statusu
if check_jboss_status('jboss01', cli_port=19990):
    print("‚úì JBoss dzia≈Ça poprawnie")
else:
    print("‚úó JBoss nie odpowiada")
```

### 4. W≈Çasne polecenia JBoss CLI

```python
from ssh_tunnel import SSHTunnel

with SSHTunnel('jboss01', 19990) as tunnel:
    commands = [
        ':read-attribute(name=server-state)',
        ':read-attribute(name=release-version)',
        'deployment-info',
        '/subsystem=datasources:read-resource'
    ]
    
    for cmd in commands:
        jboss_cmd = [
            '/opt/jboss/bin/jboss-cli.sh',
            '--connect',
            '--controller=localhost:19990',
            f'--command={cmd}'
        ]
        
        rc, out, err = tunnel.execute_command(jboss_cmd)
        print(f"\n{cmd}:\n{out}")
```

### 5. Monitoring wielu serwer√≥w

```python
from ssh_tunnel import SSHTunnel

hosts = ['jboss01', 'jboss02', 'jboss03']
results = {}

for host in hosts:
    print(f"\n{'='*60}")
    print(f"Sprawdzam: {host}")
    print(f"{'='*60}")
    
    try:
        with SSHTunnel(host, 19990) as tunnel:
            command = [
                '/opt/jboss/bin/jboss-cli.sh',
                '--connect',
                '--controller=localhost:19990',
                '--command=:read-attribute(name=server-state)'
            ]
            
            rc, out, err = tunnel.execute_command(command)
            
            if rc == 0 and 'running' in out.lower():
                results[host] = 'RUNNING ‚úì'
            else:
                results[host] = 'NOT RUNNING ‚úó'
                
    except Exception as e:
        results[host] = f'ERROR: {e} ‚úó'

# Podsumowanie
print(f"\n{'='*60}")
print("PODSUMOWANIE")
print(f"{'='*60}")
for host, status in results.items():
    print(f"{host:20} {status}")
```

### 6. Forwarding bazy danych

```python
from ssh_tunnel import SSHTunnel
import psycopg2

# Tunel do PostgreSQL
with SSHTunnel('db-server', 5432, local_port=5433) as tunnel:
    # Po≈ÇƒÖcz siƒô z bazƒÖ przez tunel
    conn = psycopg2.connect(
        host='localhost',
        port=5433,
        database='mydb',
        user='user',
        password='pass'
    )
    
    cursor = conn.cursor()
    cursor.execute("SELECT version();")
    print(cursor.fetchone())
    
    conn.close()
```

### 7. Multi-port forwarding

```python
from ssh_tunnel import SSHTunnel

# Otw√≥rz wiele tuneli jednocze≈õnie
tunnels = [
    SSHTunnel('jboss01', 19990, local_port=19990),  # JBoss CLI
    SSHTunnel('jboss01', 8080, local_port=8080),    # HTTP
    SSHTunnel('jboss01', 9990, local_port=9990),    # Management
]

try:
    # Uruchom wszystkie tunele
    for tunnel in tunnels:
        tunnel.start()
    
    # Wykonaj operacje przez tunele
    # ...
    
finally:
    # Zamknij wszystkie tunele
    for tunnel in tunnels:
        tunnel.stop()
```

### 8. Z timeoutem i retry

```python
from ssh_tunnel import SSHTunnel
import time

def execute_with_retry(tunnel, command, retries=3):
    """Wykonaj polecenie z retry"""
    for attempt in range(retries):
        rc, out, err = tunnel.execute_command(command, timeout=30)
        
        if rc == 0:
            return out
        
        print(f"Pr√≥ba {attempt + 1}/{retries} nieudana, ponawiam...")
        time.sleep(5)
    
    raise Exception(f"Nie uda≈Ço siƒô wykonaƒá polecenia po {retries} pr√≥bach")

# U≈ºycie
with SSHTunnel('jboss01', 19990) as tunnel:
    result = execute_with_retry(tunnel, ['curl', 'localhost:19990/health'])
    print(result)
```

---

## üîß Integracja z Jenkins

### Pipeline - podstawowy

```groovy
pipeline {
    agent {
        docker {
            image 'python:3.11-slim'
            args '-v /opt/jboss:/opt/jboss:ro'
        }
    }
    
    parameters {
        string(name: 'JBOSS_HOST', defaultValue: 'jboss01', description: 'Hostname JBoss')
        string(name: 'CLI_PORT', defaultValue: '19990', description: 'Port JBoss CLI')
    }
    
    stages {
        stage('Prepare SSH Tunnel') {
            steps {
                script {
                    // Pobierz bibliotekƒô z repo
                    sh 'curl -O https://raw.githubusercontent.com/your-repo/ssh_tunnel.py'
                    
                    // Lub skopiuj z workspace
                    // sh 'cp ${WORKSPACE}/ssh_tunnel.py .'
                }
            }
        }
        
        stage('Check JBoss Status') {
            steps {
                sh """
                    python ssh_tunnel.py ${params.JBOSS_HOST} ${params.CLI_PORT}
                """
            }
        }
    }
    
    post {
        always {
            echo 'Tunele SSH zosta≈Çy automatycznie zamkniƒôte'
        }
    }
}
```

### Pipeline - zaawansowany z wieloma hostami

```groovy
pipeline {
    agent {
        docker {
            image 'python:3.11-slim'
            args '-v /opt/jboss:/opt/jboss:ro -v ~/.ssh:/root/.ssh:ro'
        }
    }
    
    parameters {
        text(
            name: 'JBOSS_HOSTS', 
            defaultValue: 'jboss01\njboss02\njboss03',
            description: 'Lista host√≥w JBoss (jeden na liniƒô)'
        )
        string(name: 'CLI_PORT', defaultValue: '19990', description: 'Port JBoss CLI')
        choice(
            name: 'COMMAND',
            choices: ['status', 'version', 'deployments', 'datasources'],
            description: 'Polecenie do wykonania'
        )
    }
    
    stages {
        stage('Prepare') {
            steps {
                script {
                    writeFile file: 'ssh_tunnel.py', text: libraryResource('ssh_tunnel.py')
                    
                    writeFile file: 'check_all_hosts.py', text: """
from ssh_tunnel import SSHTunnel
import sys

hosts = '''${params.JBOSS_HOSTS}'''.strip().split('\\n')
cli_port = ${params.CLI_PORT}
command_type = '${params.COMMAND}'

commands = {
    'status': ':read-attribute(name=server-state)',
    'version': ':read-attribute(name=release-version)',
    'deployments': 'deployment-info',
    'datasources': '/subsystem=datasources:read-resource'
}

jboss_command = commands.get(command_type, commands['status'])
results = {}

print(f"\\n{'='*70}")
print(f"Sprawdzam {len(hosts)} serwer√≥w JBoss - Polecenie: {command_type}")
print(f"{'='*70}\\n")

for host in hosts:
    host = host.strip()
    if not host:
        continue
        
    print(f"\\n{'‚îÄ'*70}")
    print(f"Host: {host}")
    print(f"{'‚îÄ'*70}")
    
    try:
        with SSHTunnel(host, cli_port) as tunnel:
            cmd = [
                '/opt/jboss/bin/jboss-cli.sh',
                '--connect',
                f'--controller=localhost:{cli_port}',
                f'--command={jboss_command}'
            ]
            
            rc, out, err = tunnel.execute_command(cmd, timeout=30)
            
            if rc == 0:
                print(f"‚úì {host}: SUCCESS")
                print(out)
                results[host] = 'SUCCESS'
            else:
                print(f"‚úó {host}: FAILED")
                print(err)
                results[host] = 'FAILED'
                
    except Exception as e:
        print(f"‚úó {host}: ERROR - {e}")
        results[host] = 'ERROR'

# Podsumowanie
print(f"\\n{'='*70}")
print("PODSUMOWANIE")
print(f"{'='*70}")
success_count = sum(1 for v in results.values() if v == 'SUCCESS')
total_count = len(results)

for host, status in results.items():
    icon = '‚úì' if status == 'SUCCESS' else '‚úó'
    print(f"{icon} {host:30} {status}")

print(f"\\n{success_count}/{total_count} serwer√≥w dzia≈Ça poprawnie")
print(f"{'='*70}\\n")

sys.exit(0 if success_count == total_count else 1)
"""
                }
            }
        }
        
        stage('Execute on All Hosts') {
            steps {
                sh 'python check_all_hosts.py'
            }
        }
    }
    
    post {
        success {
            echo '‚úì Wszystkie serwery sprawdzone pomy≈õlnie'
        }
        failure {
            echo '‚úó Niekt√≥re serwery nie odpowiadajƒÖ'
        }
        always {
            echo 'üßπ Czyszczenie tuneli SSH'
        }
    }
}
```

### Pipeline - deployment verification

```groovy
pipeline {
    agent any
    
    parameters {
        string(name: 'APP_NAME', description: 'Nazwa aplikacji do sprawdzenia')
        string(name: 'EXPECTED_VERSION', description: 'Oczekiwana wersja')
    }
    
    stages {
        stage('Verify Deployment') {
            steps {
                script {
                    writeFile file: 'verify_deployment.py', text: """
from ssh_tunnel import SSHTunnel

app_name = '${params.APP_NAME}'
expected_version = '${params.EXPECTED_VERSION}'
hosts = ['jboss01', 'jboss02', 'jboss03']

all_ok = True

for host in hosts:
    with SSHTunnel(host, 19990) as tunnel:
        cmd = [
            '/opt/jboss/bin/jboss-cli.sh',
            '--connect',
            '--controller=localhost:19990',
            f'--command=/deployment={app_name}:read-attribute(name=runtime-name)'
        ]
        
        rc, out, err = tunnel.execute_command(cmd)
        
        if expected_version in out:
            print(f"‚úì {host}: Wersja {expected_version} wdro≈ºona poprawnie")
        else:
            print(f"‚úó {host}: Nieprawid≈Çowa wersja!")
            all_ok = False

exit(0 if all_ok else 1)
"""
                    sh 'python verify_deployment.py'
                }
            }
        }
    }
}
```

### Shared Library Jenkins

Mo≈ºesz te≈º stworzyƒá Jenkins Shared Library:

```groovy
// vars/sshTunnel.groovy
def check(String host, int port = 19990) {
    sh """
        python -c "
from ssh_tunnel import SSHTunnel, check_jboss_status
import sys
sys.exit(0 if check_jboss_status('${host}', ${port}) else 1)
        "
    """
}

def execute(String host, int port, List command) {
    sh """
        python -c "
from ssh_tunnel import SSHTunnel
with SSHTunnel('${host}', ${port}) as t:
    rc, out, _ = t.execute_command(${command})
    print(out)
    exit(rc)
        "
    """
}
```

U≈ºycie w Pipeline:

```groovy
@Library('shared-lib') _

pipeline {
    agent any
    stages {
        stage('Check') {
            steps {
                sshTunnel.check('jboss01', 19990)
            }
        }
    }
}
```

---

## üîí Bezpiecze≈Ñstwo

### Best Practices

#### 1. U≈ºywaj kluczy SSH zamiast hase≈Ç

```bash
# Generuj silny klucz
ssh-keygen -t ed25519 -C "jenkins@company.com"

# LUB RSA 4096-bit
ssh-keygen -t rsa -b 4096 -C "jenkins@company.com"

# Ustaw odpowiednie uprawnienia
chmod 700 ~/.ssh
chmod 600 ~/.ssh/id_ed25519
chmod 644 ~/.ssh/id_ed25519.pub
```

#### 2. Ogranicz dostƒôp SSH

W `~/.ssh/authorized_keys` na serwerze:

```bash
# Ogranicz do konkretnych komend
command="/opt/scripts/allowed-commands.sh" ssh-ed25519 AAAA...

# Ogranicz do konkretnych IP
from="10.20.30.0/24" ssh-ed25519 AAAA...

# Wy≈ÇƒÖcz port forwarding (je≈õli nie potrzebny)
no-port-forwarding,no-agent-forwarding,no-X11-forwarding ssh-ed25519 AAAA...
```

#### 3. Konfiguracja SSH dla produkcji

Edytuj kod, usu≈Ñ niebezpieczne opcje:

```python
ssh_cmd = [
    'ssh',
    '-f', '-N',
    '-L', f'{self.local_port}:localhost:{self.remote_port}',
    f'{self.ssh_user}@{self.remote_host}',
    # USU≈É TO W PRODUKCJI:
    # '-o', 'StrictHostKeyChecking=no',  
    # DODAJ TO:
    '-o', 'StrictHostKeyChecking=yes',
    '-o', 'ServerAliveInterval=60',
    '-o', 'ServerAliveCountMax=3',
    '-o', 'ConnectTimeout=10',
    '-o', 'PasswordAuthentication=no'  # Wymuszaj klucze
]
```

#### 4. Zasada najmniejszych uprawnie≈Ñ

```bash
# Dedykowany u≈ºytkownik dla tuneli
sudo useradd -m -s /bin/bash jenkins-tunnel
sudo su - jenkins-tunnel

# Generuj klucze dla tego u≈ºytkownika
ssh-keygen -t ed25519

# Ogranicz sudo tylko do potrzebnych komend
# /etc/sudoers.d/jenkins-tunnel
jenkins-tunnel ALL=(ALL) NOPASSWD: /usr/bin/systemctl status jboss
```

#### 5. Monitoring i audyt

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/ssh-tunnels.log'),
        logging.StreamHandler()
    ]
)

class SSHTunnel:
    def start(self):
        logging.info(f"Creating tunnel: {self.ssh_user}@{self.remote_host}:{self.remote_port}")
        # ... reszta kodu
    
    def stop(self):
        logging.info(f"Closing tunnel: {self.remote_host}:{self.remote_port}")
        # ... reszta kodu
```

#### 6. Secrets management

Nigdy nie hardcoduj credentials w kodzie:

```python
import os

# Pobieraj z zmiennych ≈õrodowiskowych
SSH_USER = os.getenv('SSH_USER', 'jenkins')
SSH_KEY_PATH = os.getenv('SSH_KEY_PATH', '~/.ssh/id_ed25519')

# Lub z Jenkins Credentials
# W Pipeline: withCredentials([sshUserPrivateKey(...)]) { }
```

#### 7. Network segmentation

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     DMZ / Public                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                          ‚îÇ
‚îÇ  ‚îÇ  Jenkins   ‚îÇ  SSH (22) tylko do specific hosts        ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ SSH Tunnel
         ‚îÇ (enkapsuluje wszystkie porty)
         ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Internal Network / Private                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ  jboss01   ‚îÇ    ‚îÇ  jboss02   ‚îÇ    ‚îÇ  database  ‚îÇ      ‚îÇ
‚îÇ  ‚îÇ  :19990    ‚îÇ    ‚îÇ  :19990    ‚îÇ    ‚îÇ  :5432     ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îÇ  (porty dostƒôpne TYLKO lokalnie)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Checklist bezpiecze≈Ñstwa

- [ ] U≈ºywasz kluczy SSH zamiast hase≈Ç
- [ ] `StrictHostKeyChecking` ustawione na `yes` w produkcji
- [ ] Klucze SSH majƒÖ odpowiednie uprawnienia (600)
- [ ] U≈ºywasz dedykowanego u≈ºytkownika dla tuneli
- [ ] W≈ÇƒÖczony logging wszystkich po≈ÇƒÖcze≈Ñ
- [ ] Tunele majƒÖ timeout i automatycznie siƒô zamykajƒÖ
- [ ] Secrets sƒÖ w zmiennych ≈õrodowiskowych, nie w kodzie
- [ ] Ograniczony dostƒôp przez `authorized_keys`
- [ ] Regularnie rotowane klucze SSH
- [ ] Monitoring nieautoryzowanych pr√≥b po≈ÇƒÖcze≈Ñ

---

## üîç Troubleshooting

### Problem: "Connection refused"

```
‚úó ssh: connect to host jboss01 port 22: Connection refused
```

**RozwiƒÖzania:**

```bash
# 1. Sprawd≈∫ czy SSH dzia≈Ça na serwerze
ssh -v user@jboss01

# 2. Sprawd≈∫ czy port 22 jest otwarty
nc -zv jboss01 22
telnet jboss01 22

# 3. Sprawd≈∫ firewall na kliencie
sudo iptables -L -n | grep 22

# 4. Sprawd≈∫ czy serwer SSH dzia≈Ça
# (na serwerze docelowym)
sudo systemctl status sshd
sudo systemctl start sshd
```

### Problem: "Permission denied (publickey)"

```
‚úó Permission denied (publickey,password).
```

**RozwiƒÖzania:**

```bash
# 1. Sprawd≈∫ czy klucz jest dodany
ssh-add -l

# 2. Dodaj klucz do ssh-agent
eval $(ssh-agent)
ssh-add ~/.ssh/id_ed25519

# 3. Skopiuj klucz na serwer
ssh-copy-id user@jboss01

# 4. Sprawd≈∫ uprawnienia
chmod 700 ~/.ssh
chmod 600 ~/.ssh/id_ed25519
chmod 644 ~/.ssh/id_ed25519.pub

# 5. Debug
ssh -vvv user@jboss01
```

### Problem: Tunel siƒô tworzy, ale port nie odpowiada

```
‚úì Tunel SSH uruchomiony pomy≈õlnie!
‚úó Tunel SSH nie odpowiada na porcie 19990
```

**RozwiƒÖzania:**

```bash
# 1. Sprawd≈∫ czy us≈Çuga dzia≈Ça na zdalnym serwerze
# (na serwerze jboss01)
netstat -tlnp | grep 19990
ss -tlnp | grep 19990

# 2. Sprawd≈∫ czy tunel faktycznie dzia≈Ça
ps aux | grep ssh | grep 19990

# 3. Sprawd≈∫ czy lokalny port jest wolny
netstat -tlnp | grep 19990  # na kliencie

# 4. Test manualny
ssh -L 19990:localhost:19990 user@jboss01
# W innym terminalu:
curl localhost:19990

# 5. Sprawd≈∫ logi SSH
tail -f /var/log/auth.log  # na serwerze
```

### Problem: Tunel siƒô roz≈ÇƒÖcza

```
‚úó Broken pipe
```

**RozwiƒÖzania:**

```python
# Dodaj keep-alive w kodzie
ssh_cmd = [
    'ssh', '-f', '-N',
    '-L', f'{self.local_port}:localhost:{self.remote_port}',
    f'{self.ssh_user}@{self.remote_host}',
    '-o', 'ServerAliveInterval=30',     # ping co 30s
    '-o', 'ServerAliveCountMax=5',      # 5 pr√≥b
    '-o', 'TCPKeepAlive=yes'            # TCP keep-alive
]
```

```bash
# Lub w ~/.ssh/config
Host jboss01
    ServerAliveInterval 30
    ServerAliveCountMax 5
    TCPKeepAlive yes
```

### Problem: "Address already in use"

```
‚úó bind: Address already in use
```

**RozwiƒÖzania:**

```bash
# 1. Znajd≈∫ proces u≈ºywajƒÖcy portu
lsof -i :19990
netstat -tlnp | grep 19990

# 2. Zabij proces
kill <PID>

# 3. Lub u≈ºyj innego lokalnego portu
tunnel = SSHTunnel('jboss01', 19990, local_port=19991)
```

### Problem: Timeout podczas wykonywania polecenia

```
‚úó Timeout - polecenie przekroczy≈Ço limit 60s
```

**RozwiƒÖzania:**

```python
# Zwiƒôksz timeout
rc, out, err = tunnel.execute_command(command, timeout=300)  # 5 minut

# Lub podziel na mniejsze operacje
# Zamiast jednego du≈ºego zapytania, zr√≥b kilka ma≈Çych
```

### Problem: "Host key verification failed"

```
‚úó Host key verification failed.
```

**RozwiƒÖzania:**

```bash
# 1. Dodaj host do known_hosts
ssh-keyscan jboss01 >> ~/.ssh/known_hosts

# 2. Lub akceptuj przy pierwszym po≈ÇƒÖczeniu
ssh user@jboss01  # wpisz 'yes'

# 3. W produkcji NIE u≈ºywaj StrictHostKeyChecking=no!
```

### Debug Mode

W≈ÇƒÖcz szczeg√≥≈Çowy logging:

```python
import subprocess
import sys

# Dodaj verbose do SSH
ssh_cmd = [
    'ssh', '-v', '-v', '-v',  # Triple verbose
    '-f', '-N',
    '-L', f'{local_port}:localhost:{remote_port}',
    f'{ssh_user}@{remote_host}'
]

result = subprocess.run(ssh_cmd, capture_output=True, text=True)
print("STDOUT:", result.stdout)
print("STDERR:", result.stderr)
```

### Czƒôsto sprawdzane komendy

```bash
# Lista wszystkich tuneli SSH
ps aux | grep 'ssh.*-L'

# Zabij wszystkie tunele
pkill -f 'ssh.*-L'

# Sprawd≈∫ otwarte po≈ÇƒÖczenia
netstat -tn | grep :22

# Test po≈ÇƒÖczenia bez tunelu
nc -zv jboss01 22

# Test po≈ÇƒÖczenia przez tunel
nc -zv localhost 19990
```

---

## ‚ùì FAQ

### Q: Czy tunel SSH jest bezpieczny?

**A:** Tak! SSH u≈ºywa silnego szyfrowania (AES-256, ChaCha20) i jest standardem w bran≈ºy. Wszystkie dane przesy≈Çane przez tunel sƒÖ zaszyfrowane end-to-end.

### Q: Czy mogƒô u≈ºywaƒá jednego tunelu dla wielu po≈ÇƒÖcze≈Ñ?

**A:** Tak! Jeden tunel SSH mo≈ºe obs≈Çugiwaƒá wiele r√≥wnoleg≈Çych po≈ÇƒÖcze≈Ñ do tego samego portu. SSH multiplexuje po≈ÇƒÖczenia.

```python
with SSHTunnel('jboss01', 19990) as tunnel:
    # Mo≈ºesz wykonaƒá wiele operacji r√≥wnolegle
    thread1 = threading.Thread(target=operation1)
    thread2 = threading.Thread(target=operation2)
    thread1.start()
    thread2.start()
```

### Q: Jak wp≈Çywa to na wydajno≈õƒá?

**A:** Minimalne narzuty:
- Szyfrowanie: ~1-5% CPU
- Latencja: +1-10ms (przez sieƒá)
- Throughput: 90-95% natywnej przepustowo≈õci

Dla wiƒôkszo≈õci zastosowa≈Ñ (CLI, API) r√≥≈ºnica jest niezauwa≈ºalna.

### Q: Co je≈õli muszƒô forwardowaƒá wiele port√≥w?

**A:** Mo≈ºesz utworzyƒá wiele tuneli:

```python
tunnels = [
    SSHTunnel('jboss01', 19990),  # CLI
    SSHTunnel('jboss01', 8080),   # HTTP
    SSHTunnel('jboss01', 9990),   # Management
]

for tunnel in tunnels:
    tunnel.start()
```

Lub u≈ºyƒá jednego po≈ÇƒÖczenia SSH z wieloma forwardingami:

```bash
ssh -L 19990:localhost:19990 \
    -L 8080:localhost:8080 \
    -L 9990:localhost:9990 \
    user@jboss01
```

### Q: Jak obs≈Çu≈ºyƒá sytuacjƒô, gdy serwer ma wiele interfejs√≥w?

**A:** Mo≈ºesz forwardowaƒá do konkretnego interfejsu:

```python
# Forward do konkretnego IP na zdalnym ho≈õcie
ssh_cmd = [
    'ssh', '-f', '-N',
    '-L', f'{local_port}:192.168.1.100:{remote_port}',  # konkretny IP
    f'{ssh_user}@{remote_host}'
]
```

### Q: Czy mogƒô u≈ºywaƒá tego w kontenerach Docker?

**A:** Tak! Upewnij siƒô, ≈ºe:

1. Masz zainstalowany SSH client w kontenerze:
   ```dockerfile
   RUN apt-get update && apt-get install -y openssh-client
   ```

2. Klucze SSH sƒÖ dostƒôpne:
   ```bash
   docker run -v ~/.ssh:/root/.ssh:ro myimage
   ```

3. Sieƒá kontenera ma dostƒôp do hosta docelowego.

### Q: Jak d≈Çugo mo≈ºe dzia≈Çaƒá tunel?

**A:** Tunel mo≈ºe dzia≈Çaƒá w niesko≈Ñczono≈õƒá, je≈õli:
- W≈ÇƒÖczony ServerAliveInterval (ping co X sekund)
- Sieƒá jest stabilna
- Nie ma timeout√≥w na firewallu

```python
ssh_cmd = [
    'ssh', '-f', '-N',
    '-o', 'ServerAliveInterval=60',    # Ping co 60s
    '-o', 'ServerAliveCountMax=3',     # 3 nieudane = disconnect
    '-o', 'ExitOnForwardFailure=yes',  # Wyjd≈∫ przy b≈Çƒôdzie forwarding
    # ... rest
]
```

### Q: Co z proxy/jump hosts?

**A:** SSH obs≈Çuguje ProxyJump:

```python
ssh_cmd = [
    'ssh', '-f', '-N',
    '-J', 'jumphost',  # Po≈ÇƒÖcz przez jumphost
    '-L', f'{local_port}:localhost:{remote_port}',
    f'{ssh_user}@{remote_host}'
]
```

Lub w `~/.ssh/config`:
```
Host jboss01
    ProxyJump jumphost
```

### Q: Jak monitorowaƒá tunele w produkcji?

**A:** Dodaj monitoring:

```python
import prometheus_client
from prometheus_client import Counter, Gauge

tunnel_created = Counter('ssh_tunnel_created', 'Tunnels created')
tunnel_active = Gauge('ssh_tunnel_active', 'Active tunnels')
tunnel_errors = Counter('ssh_tunnel_errors', 'Tunnel errors')

class SSHTunnel:
    def start(self):
        tunnel_created.inc()
        tunnel_active.inc()
        # ... existing code
        
    def stop(self):
        tunnel_active.dec()
        # ... existing code
```

### Q: Czy mo≈ºna u≈ºywaƒá z Windows?

**A:** Tak, je≈õli masz SSH client:

1. Windows 10/11 - wbudowany OpenSSH:
   ```powershell
   ssh -L 19990:localhost:19990 user@jboss01
   ```

2. Git Bash - zawiera SSH
3. WSL - pe≈Çne SSH capabilities

Kod Python dzia≈Ça identycznie.

### Q: Jak testowaƒá lokalnie?

**A:** U≈ºyj localhost:

```python
# Testuj bez prawdziwego SSH
tunnel = SSHTunnel('localhost', 19990, ssh_user='yourusername')
tunnel.start()
```

Lub mock SSH w testach:

```python
import unittest
from unittest.mock import patch, MagicMock

class TestSSHTunnel(unittest.TestCase):
    @patch('subprocess.run')
    def test_start_tunnel(self, mock_run):
        mock_run.return_value = MagicMock(returncode=0)
        
        tunnel = SSHTunnel('testhost', 19990)
        result = tunnel.start()
        
        self.assertTrue(result)
        mock_run.assert_called_once()
```

---

## üìö Dodatkowe zasoby

### Dokumentacja

- [OpenSSH Manual](https://www.openssh.com/manual.html)
- [SSH Port Forwarding](https://www.ssh.com/academy/ssh/tunneling/example)
- [Python subprocess](https://docs.python.org/3/library/subprocess.html)

### Bezpiecze≈Ñstwo

- [SSH Best Practices](https://www.ssh.com/academy/ssh/security)
- [NIST SSH Guidelines](https://nvlpubs.nist.gov/nistpubs/ir/2015/NIST.IR.7966.pdf)

### Narzƒôdzia

- [autossh](https://www.harding.motd.ca/autossh/) - Auto-restart SSH tunnels
- [sshuttle](https://github.com/sshuttle/sshuttle) - VPN over SSH
- [mosh](https://mosh.org/) - Mobile Shell (alternative to SSH)

---

## üìù Changelog

### v1.0.0 (2025-10-31)

- ‚ú® Pierwsza wersja
- üîê Context manager dla automatycznego lifecycle
- üìä Sprawdzanie statusu tunelu
- ‚è±Ô∏è Timeout dla polece≈Ñ
- üìù Pe≈Çna dokumentacja
- üß™ Przyk≈Çady u≈ºycia
- üîß Integracja z Jenkins

---

## üìÑ Licencja

MIT License - mo≈ºesz swobodnie u≈ºywaƒá w projektach komercyjnych i open source.

---

## üë• Autorzy

Utworzone dla projekt√≥w DevOps/SRE wymagajƒÖcych bezpiecznego dostƒôpu do serwis√≥w wewnƒôtrznych.

---

## ü§ù Wk≈Çad

Zg≈Çaszaj issues i pull requesty na GitHubie!

### Jak pom√≥c:

1. Fork repozytorium
2. Utw√≥rz branch (`git checkout -b feature/amazing-feature`)
3. Commit zmian (`git commit -m 'Add amazing feature'`)
4. Push do brancha (`git push origin feature/amazing-feature`)
5. Otw√≥rz Pull Request

---

## üìû Kontakt

Pytania? Problemy? Otw√≥rz issue na GitHubie!

---

**Happy Tunneling! üöÄ**
